<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>调度场算法(Shunting Yard Algorithm)</title>
    <url>/2022/10/23/%E8%B0%83%E5%BA%A6%E5%9C%BA%E7%AE%97%E6%B3%95-Shunting-Yard-Algorithm/</url>
    <content><![CDATA[<h1 id="调度场算法"><a href="#调度场算法" class="headerlink" title="调度场算法"></a>调度场算法</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>调度场算法用于将中缀表达式转换为后缀表达式(逆波兰表达式).</p>
<span id="more"></span>
<blockquote>
<p>中缀表达式5*(6&#x2F;2+7)的后缀表达式为 6 2 &#x2F; 7 + 5 * </p>
</blockquote>
<p> 后缀表达式无需考虑运算符的优先级(不需要使用括号标识优先级),只需按照运算符从左到右的出现顺序进行运算,即可得到表达式的值,因此便于计算机对其进行识别处理.</p>
<h3 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h3><blockquote>
<p>使用一个栈存储表达式的运算符</p>
</blockquote>
<p>首先遍历待中缀表达式</p>
<ul>
<li>遇到运算数时,直接将其添加到后缀表达式中.</li>
<li>遇到运算符,运算条件为:<u>运算符栈非空并且栈顶运算符的优先级不低于当前运算符的优先级</u><ul>
<li>如果为算术运算符,先判断是否满足运算条件：                       <ul>
<li>满足运算条件<br>栈顶的运算符弹出并且添加到后缀表达式中并(表示执行了一次运算).继续判断运算条件(若满足,则重复上述过程),直至不满足运算条件</li>
<li>不满足运算条件<br>将当前运算符压入栈中</li>
</ul>
</li>
<li>如果为括号,需要分开处理：   <ul>
<li>对于左括号,表示将在括号内进行一段子运算,因此在整个表达式中,其优先级最高,直接将其压入运算符栈.可合并到(1)中不满足运算条件的情况.但入栈后,表示进行括号内的子运算,因此入栈后的左括号的优先级变为最低.<br> 可采用如下方法,实现左括号入栈后优先级由最高变为最低:将ASCII码表中与左括号相邻的符号压入栈中,表示左括号入栈后优先级发生变化.        </li>
<li>对于右括号,其优先级为最低, 表示当前括号内的表达式结束,因此其优先级为最低,这样即可完成括号内剩余运算符的运算：将栈顶运算符依次弹出并且进行运算直至遇到左括号.可将完成括号内剩余运算的情形合并到(1)中满足运算条件进行运算的情况,但不同的是左括号出栈时直接结束需当前的运算并且右括号不入栈.<br> 表达式读取完成后,运算符栈内可能仍存在运算符,因此需完成这些剩余运算符的运算.</li>
</ul>
</li>
</ul>
</li>
<li>特殊情况(负数)的处理<br>运算数为负数时,’-‘表示负号,为一元运算符,而非二元运减号(二元运算符).<br>处理方法:提前向运算数栈中压入一个0,将该负数转换为0与该负数绝对值的一次减法运算.<br>根据负号出现的位置分两种情况处理:<ul>
<li>负数出现在表达式开始处(第一个运算数为负数):开始运算前先将0压入运算数栈中.</li>
<li>负数出现在表达式中间或结尾处(括号中出现负数):读取到左括号时先将0压入运算数栈中,再将左括号压入运算符栈.</li>
</ul>
</li>
</ul>
<p>完成表达式的遍历后,栈中可能仍存在运算符.将这些剩余的运算符依次从栈顶弹出,并且添加到后缀表达式中(表示依次执行这些栈顶运算符的运算).最终得到后缀表达式将其输出.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现调度场算法,将中缀表达式转换为后缀表达式</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; opr;                      <span class="comment">//存储运算符</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; precedence;  <span class="comment">// 存储运算符的优先级</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; arity;       <span class="comment">// 存储运算符的元数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eraseSpace</span><span class="params">(string&amp; expr)</span>         <span class="comment">// 去除表达式中的空格</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = expr.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>); i != string::npos; i = expr.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>, i))</span><br><span class="line">        &#123;</span><br><span class="line">            expr.<span class="built_in">erase</span>(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initPrecedence</span><span class="params">(<span class="type">const</span> string &amp;tokens)</span>       <span class="comment">// 初始化优先级表</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> opr : tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (opr)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                precedence[opr] = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">                precedence[opr] = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>: precedence[opr] = <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;!&#x27;</span>: precedence[opr] = <span class="number">4</span>; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                precedence.<span class="built_in">insert</span>(&#123;opr, <span class="number">5</span>&#125;); <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\&#x27;&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                precedence[opr] = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initArity</span><span class="params">(<span class="type">const</span> string &amp;tokens)</span>            <span class="comment">// 初始化操作数表</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> opr : tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (opr)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">                    arity[opr] = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;!&#x27;</span>:</span><br><span class="line">                    arity[opr] = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\&#x27;&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                    arity[opr] = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">extractNumFromexpr</span><span class="params">(string expr, <span class="type">int</span>&amp; i)</span>  <span class="comment">//提取出表达式中的运算数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string opd;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(expr[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            opd += expr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(expr[i] == <span class="string">&#x27;.&#x27;</span>)  <span class="comment">// 考虑小数的情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            opd += expr[i++];</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isdigit</span>(expr[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                opd += expr[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> opd;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">infixToPostfix</span><span class="params">(string &amp;expr)</span>             <span class="comment">// 将中缀表达式转换为后缀表达式</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">eraseSpace</span>(expr);</span><br><span class="line">        <span class="function">string <span class="title">allOpr</span><span class="params">(<span class="string">&quot;+-*/%^!(\&#x27;)[\\]&#123;|&#125;&quot;</span>)</span></span>;        <span class="comment">// 表达式中所有可能出现的运算符</span></span><br><span class="line">        <span class="built_in">initPrecedence</span>(allOpr), <span class="built_in">initArity</span>(allOpr);  <span class="comment">// 建立运算符与其优先级和元数的映射</span></span><br><span class="line">        string postfixExpr;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *考虑特殊情况:运算数为负数,提前向运算数栈中压入一个0, 将运算数转换为0与该负数的绝对值进行一次减法运算的运算结果</span></span><br><span class="line"><span class="comment">        * 根据负数出现的位置分两种情况考虑：</span></span><br><span class="line"><span class="comment">        * 负数出现在表达式开头(第一个运算数为负数), 此时该负数不加括号;</span></span><br><span class="line"><span class="comment">        * 负数出现在表达式的中间和结尾(负数出现的位置不在表达式开头),此时该负数加括号;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 第一个运算数为负数的情况</span></span><br><span class="line">        <span class="keyword">if</span>(expr[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)    <span class="comment">// 该负数不加括号</span></span><br><span class="line">        &#123;</span><br><span class="line">            postfixExpr += <span class="string">&#x27;0&#x27;</span>;; <span class="comment">// 提前向后缀表达式中添加0, 将负数转换为0与该负数的绝对值的一次减法运算</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; expr.<span class="built_in">length</span>() &amp;&amp; expr[i] != <span class="string">&#x27;=&#x27;</span> ;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isalnum</span>(expr[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isalpha</span>(expr[i]))                            <span class="comment">//读取到变量</span></span><br><span class="line">                &#123;</span><br><span class="line">                    postfixExpr += expr[i++];                   <span class="comment">// !!!注意: 向后缀表达式中添加完该变量后需将i向后移,读取下一个字符</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>                                            <span class="comment">//读取到数字</span></span><br><span class="line">                &#123;</span><br><span class="line">                    postfixExpr += <span class="built_in">extractNumFromexpr</span>(expr, i); <span class="comment">//将该数字从表达式中进行提取,并且添加到后缀表达式中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                                <span class="comment">//读取到运算符</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> currOp = expr[i];                          <span class="comment">//记录当前的运算符</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * 运算条件为运算符栈非空(存在运算符)并且栈顶运算符的优先级不低于当前运算符的优先级</span></span><br><span class="line"><span class="comment">                * 若满足运算条件, 则代表进行一次运算, 弹出栈顶运算符</span></span><br><span class="line"><span class="comment">                * 再将新的栈顶运算符的优先级与当前运算符的优先级进行比较</span></span><br><span class="line"><span class="comment">                * 若满足运算条件,则重复上述过程, 直至栈顶运算符为空或者栈顶运算符的优先级低于当前运算符的优先级(不满足运算条件)</span></span><br><span class="line"><span class="comment">                * 此时已不满足运算条件,因此不进行运算:将当前运算符压入栈中</span></span><br><span class="line"><span class="comment">                * 特殊情况的合并: 当前运算符为右括号时,其优先级为最低, 继续完成括号内剩余运算符的运算,将这些运算符依次弹出(该情况合并到上述过程中进行运算条件的判断)</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">while</span>(!opr.<span class="built_in">empty</span>() &amp;&amp; precedence[opr.<span class="built_in">top</span>()] &gt;= precedence[expr[i]])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(arity[opr.<span class="built_in">top</span>()])   <span class="comment">//栈顶运算符为算术运算符</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 进行一次运算,将运算符添加到后缀表达式中</span></span><br><span class="line">                        postfixExpr += opr.<span class="built_in">top</span>();</span><br><span class="line">                        <span class="comment">// 完成此次运算 从栈中弹出运算符</span></span><br><span class="line">                        opr.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>                   <span class="comment">//当前的运算符为右括号,且栈顶运算符为左括号的情况</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        opr.<span class="built_in">pop</span>();        <span class="comment">//将左括号从运算符栈中弹出(左括号不添加到后缀表达式中)</span></span><br><span class="line">                        <span class="keyword">break</span>;            <span class="comment">//此时已经完成括号内的所有运算,跳出本次循环</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前运算符为左括号</span></span><br><span class="line">                <span class="keyword">if</span>(currOp == <span class="string">&#x27;(&#x27;</span> || currOp == <span class="string">&#x27;[&#x27;</span> || currOp == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                   <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    * 左括号入栈后表示将在括号内进行一段子运算,因此入栈后的左括号的优先级变为最低</span></span><br><span class="line"><span class="comment">                    * 使用ASCII码表中与左括号相邻的符号表示入栈后的左括号, 以实现入栈后左括号优先级发生变化</span></span><br><span class="line"><span class="comment">                    * 用单引号&#x27;\&#x27;&#x27;表示入栈后的左圆括号&#x27;(&#x27;, 原因:单引号的ASCII码值比左圆括号的ASCII值小1</span></span><br><span class="line"><span class="comment">                    * 用反斜杠&#x27;\\&#x27;表示入栈后的左方括号&#x27;[&#x27;, 原因:反斜杠的ASCII码值比左方括号的ASCII值大1</span></span><br><span class="line"><span class="comment">                    * 使用竖杠&#x27;|&#x27; 表示入栈后的左花括号&#x27;&#123;&#x27;, 原因:  竖杠的ASCII码值比左花括号的ASCII值大1</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    currOp == <span class="string">&#x27;(&#x27;</span> ? currOp-- : currOp++;</span><br><span class="line">                    <span class="keyword">if</span>(expr[i + <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>) <span class="comment">// 负数未出现在表达式开头的情况</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        postfixExpr += <span class="string">&#x27;0&#x27;</span>;;  <span class="comment">// 提取向后缀表达中添加&#x27;0&#x27;, 将运算数转换为0与该负数的绝对值进行一次减法运算</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(!(currOp == <span class="string">&#x27;)&#x27;</span> || currOp == <span class="string">&#x27;]&#x27;</span> || currOp == <span class="string">&#x27;&#125;&#x27;</span>))  <span class="comment">// 不满足运算条件, 当前运算符不是右括号时,将运算符入栈</span></span><br><span class="line">                &#123;</span><br><span class="line">                    opr.<span class="built_in">push</span>(currOp);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;                       <span class="comment">// 读取表达式的下一个字符</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读取完表达式后,还需完成运算符栈内剩余运算符的运算然后依次将运算符从栈中弹出</span></span><br><span class="line">        <span class="keyword">while</span>(!opr.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            postfixExpr += opr.<span class="built_in">top</span>();             <span class="comment">// 进行一次运算</span></span><br><span class="line">            opr.<span class="built_in">pop</span>();                            <span class="comment">// 此次运算已完成, 弹出运算符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> postfixExpr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string expr;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin, expr))</span><br><span class="line">    &#123;</span><br><span class="line">        string ret = <span class="built_in">Solution</span>().<span class="built_in">infixToPostfix</span>(expr);</span><br><span class="line">        cout &lt;&lt; ret &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
</search>
