<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>无处不在的抉择之选择控制结构</title>
    <url>/2022/10/25/%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E7%9A%84%E6%8A%89%E6%8B%A9%E4%B9%8B%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84(Selection-Structure%EF%BC%89/</url>
    <content><![CDATA[<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>实际问题中需要根据情况的不同选择相应的处理方法,例如:</p>
<ul>
<li><p>购物的满减优惠活动</p>
</li>
<li><p>根据收入水平进行纳税</p>
</li>
<li><p>根据判别式求一元二次方程的根</p>
</li>
</ul>
<p>类似上述需要进行”分类讨论”的情形,即为选择控制结构所适用的场景.<br>对这些需分情况处理的问题进行抽象,首先要描述<strong>判断条件(condition)</strong>,然后使用分支选择结构根据判断条件对不同的情况进行相应处理.</p>
<h4 id="条件的表达"><a href="#条件的表达" class="headerlink" title="条件的表达"></a>条件的表达</h4><ul>
<li><p>C语言使用 <strong>逻辑表达式(Expression)</strong> 描述判断条件.</p>
<p>  逻辑表达式(也称布尔表达式),其值只有两种:&quot;真&quot;(true)表示满足条件,&quot;假&quot;(false)表示不满足条件.<br>  C语言通常用非0值表示&quot;真&quot;,使用0值表示&quot;假&quot;.<br>  逻辑表达式由逻辑运算符(logic operator)和操作数(operand)组成.</p>
<ul>
<li><p>逻辑运算符<br>包括逻辑与(and)、逻辑或(or)、逻辑非(not).</p>
 <table>
 <caption>C语言中的逻辑运算符</caption>
<tr align="center">
    <th>符号</th><th>类型</th><th>含义 </th><th>结合性</th><th>优先级</th>
</tr>
<tr align="center">
    <td> ! </td><td>单目运算符</td> <td>逻辑非</td><td>右结合(从右到左)</td><td>最高</td>
</tr>
<tr align="center">
    <td align> && </td><td>双目运算符</td><td>逻辑与</td><td>左结合(从左到右)</td><td>较高</td>
</tr>
<tr align="center">
    <td> || </td><td>双目运算符</td><td>逻辑或</td><td>左结合(从左到右)</td><td>较低</td>
</table>

<p>其中双目运算符逻辑与和逻辑或具有<u>&quot;短路特性&quot;</u>:  </p>
<p>若表达式的值可由先计算的左操作数单独推导,则不再计算右操作数的值.</p>
<ul>
<li>运算符&amp;&amp;左侧操作数的值为&quot;假&quot;时,不再计算右侧的操作数的值<br>运算符&amp;&amp;左侧操作数的值为&quot;真&quot;时,才计算右侧的操作数的值</li>
<li>运算符||左侧操作数的值为&quot;真&quot;时,不再计算右侧操作数的值<br>运算符||左侧操作数的值为&quot;假&quot;时,才计算右侧的操作数的值</li>
</ul>
<p>例如下面这段代码输出为0,因为&quot;y &#x3D; 5&quot;这条赋值语句并未被执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, z;</span><br><span class="line">z = (x == <span class="number">1</span>) &amp;&amp; (y = <span class="number">5</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, y);</span><br></pre></td></tr></table></figure>
<p> 短路特性的应用: 运算符&amp;&amp;左侧的条件作为前提条件.   </p>
</li>
<li><p>操作数包括逻辑变量和关系表达式</p>
<ul>
<li>逻辑变量<br>C语言中通常用整型变量表示逻辑变量(也称为逻辑变量).<br>非0值表示&quot;真&quot;,0表示&quot;假&quot;.<br>其实C语言也提供了布尔类型,其关键字为_Bool,其值为true或false(本质上也是整数类型int,因为用1表示true”,0表示false)</li>
<li>关系表达式<br>关系表达式由关系运算符和操作数组成<ul>
<li>关系运算符即比较运算符.<table>
<caption>C语言中的关系运算符</caption>
<tr align="center">
    <th>符号</th><th>含义</th><th>优先级</th>
</tr>
<tr align="center">
    <td align="center"> < </td><td>小于</td><td rowspan="4">高</td>
</tr>
<tr align="center">
    <td> <= </td><td>小于等于</td>
</tr>
<tr align="center">
    <td> > </td><td>大于</td>
</tr>
<tr align="center">
    <td> >= </td><td>大于等于</td>
</tr>
<tr align="center">
    <td> == </td> <td>等于</td> <td rowspan="2">低</td>
</tr>
<tr align="center">
    <td>!=</td><td>不等于</td>
</tr>
</table></li>
<li>操作数包括常量、变量和表达式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="选择控制结构"><a href="#选择控制结构" class="headerlink" title="选择控制结构"></a>选择控制结构</h4><p>  根据需要处理情况的数量确定分支的数目,分支结构可分为:</p>
<ul>
<li><p>单分支选择结构</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//statements</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  满足条件(condition),则执行花括号内的若干条语句(statements).<br>  由花括号括起来的若干条语句称为语句块(也称为复合语句),语句块中仅有一条语句时,花括号可省略.</p>
<p>  e.g 若a &gt; b则交换两者的值</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &gt; b) </span><br><span class="line">&#123;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tips:<br>  可使用逗号运算符可将顺序执行、逻辑相关的多条语句合并成一条语句</p>
</blockquote>
<p>  上述代码可简化为<br>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &gt; b) temp = a, a = b, b = temp;</span><br></pre></td></tr></table></figure></p>
<p>  更高效的方式:使用位运算中的异或(^),无需借助第三个临时变量<br>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &gt; b) a ^= b, b ^= a, b a ^= b;</span><br></pre></td></tr></table></figure></p>
</li>
<li><p>双分支选择结构</p>
<ul>
<li><p>if else</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//statement1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//statement2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  满足条件condition,则执行statement1<br>  不满足条件condition,则执行statement2<br>  e.g 判断数字num是否为偶数的函数</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEven</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(num % <span class="number">2</span>))  <span class="comment">//if(num % 2 == 0)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>            <span class="comment">//if(num % 2 !=0)可写为if(num % 2)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件表达式<br>条件表达式由条件运算符和条件表达式组成.<br>条件运算符是C语言中唯一的三目运算符,提供了一种简单if-else语句的写法.<br>条件表达式的基本形式为:<br>condition ? expr1 : expr2</p>
<p>若满足条件condition,则条件表达式的值为expr1的值</p>
</li>
</ul>
<p>否则,条件表达式的值为expr2的值<br>因此,上述函数也可写为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEven</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (num % <span class="number">2</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上该函数还可简化为<br>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEven</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(num % <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>更为高效的方式：使用位运算中的与(&amp;)<br>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEven</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(num &amp; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</li>
<li><p>多分支选择结构</p>
<ul>
<li><p>级联式的if语句:else-if </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(expr1)</span><br><span class="line">&#123;</span><br><span class="line">    statement_1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(expr2)</span><br><span class="line">&#123;</span><br><span class="line">    statement_2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(expr3)</span><br><span class="line">&#123;</span><br><span class="line">    statement_3;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    statement_n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if else可以嵌套使用,用以进行深层次的判断.</p>
</li>
<li><p>switch case</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> const1:</span><br><span class="line">        statement_1; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> const2:</span><br><span class="line">        statement_2; <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> const_n:</span><br><span class="line">        statement_n; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>switch case语句由if else语句演化而来,其可以更清晰地表达选择分支结构.同时也可与if else嵌套使用<br>case后面的值必须为常量,因此具有一点的局限性.<br>注意事项：</p>
<ul>
<li>switch语句中不能定义变量,因为编译器认为这种写法会错过变量的定义.</li>
<li>case语句块中的内容执行完后需使用break跳出当前分支,否则都将归到default的情况中处理</li>
</ul>
<p>e.g<br>根据运算符opr对num1和num2进行运算并输出结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(opr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %c %d = %d\n&quot;</span>, num1, opr, num2, num + num2); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %c %d = %d\n&quot;</span>, num1, opr, num2, num - num2); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %c %d = %d\n&quot;</span>, num1, opr, num2, num * num2); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span>(!num2)  <span class="comment">//除数num2为0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Divison by zero\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %c %d = %d\n&quot;</span>, num1, opr, num2, num / num2); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Programming Language</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>周而复始的艺术之循环结构</title>
    <url>/2022/10/27/%E5%91%A8%E8%80%8C%E5%A4%8D%E5%A7%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E4%B9%8B%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84(Loop-Structure)/</url>
    <content><![CDATA[<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>人与计算机的区别体现在哪?</p>
<blockquote>
<p>人类并不擅长机械地重复行动,常常因产生厌倦而出现错误,但是更擅于思考与辨识.<br>而由人类发明的计算机则擅长按照一定的规律重复执行某些过程.</p>
</blockquote>
<p>编程的本质是以计算机的思维去思考和解决问题,然后借助编程语言实现.而计算机的思维方式不同于人类,其中最能体现计算机的思维方式的就是循环.</p>
<h3 id="循环控制结构"><a href="#循环控制结构" class="headerlink" title="循环控制结构"></a>循环控制结构</h3><p>  根据循环次数是否确定可将循环分为计数控制的循环和条件控制的循环.不管是哪种循环,其本质就是在满足特定条件的前提下,重复地执行某一过程.而循环的具体实现需要借助循环控制结构.</p>
<p>C语言提供三种循环语句实现循环结构.<br>循环语句在满足循环条件的前提下,会重复执行若干条语句,这些语句使用花括号&quot;包裹&quot;,构成循环体.</p>
<ul>
<li><p>while语句<br>  基本形式为:</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(expression)</span><br><span class="line">&#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>括号中的表达式描述循环条件,用以控制循环是否执行.</li>
<li>先判断条件,再决定是否执行循环体.</li>
</ul>
</li>
<li><p>for语句<br>  基本形式:</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(expr1; expr2; expr3)</span><br><span class="line">&#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  括号中包括三个表达式,它们之间用分号隔开.这三个表达式均可省略.</p>
<ul>
<li>表达式1仅在循环开始时执行一次初始化</li>
<li>表达式2描述循环条件,控制循环是否执行,每次循环开始前都会进行条件判断,再确定是否执行.</li>
<li>表达式3在每次循环结束后进行相应的更新</li>
</ul>
<p>  三者共同决定了循环的执行次数,可统称为控制表达式.<br>  使用逗号运算符可在控制表达式中包含多条语句,从而使得for循环更为灵活(大多数人都更倾向使用for循环).<br>  while语句和for语句描述的循环都是先判断循环条件,再决定是否执行循环体,属于当型循环.</p>
</li>
<li><p>do-while语句<br>  基本形式:</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;<span class="keyword">while</span>(expression);</span><br></pre></td></tr></table></figure>
<p>  先执行循环体,然后再进行循环条件的判断.<br>  循环体内的语句至少会执行一次.<br>  do-while语句描述的循环属于直到型循环.</p>
</li>
</ul>
<ul>
<li><p>三种循环语句的比较(如何选择)</p>
<ul>
<li><p>大部分情况的循环都可使用这for语句和while语句进行描述.一般而言,习惯使用for语句表示循环次数确定的计数控制的循环,使用while语句表达循环次数未知的条件控制的循环.</p>
<ul>
<li><p>输入数字n,求从1到n的前n项和sum<br>  显然这是一个计数控制的循环,是一个累加的过程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对于一个数字num, 从个位开始获取其每一位上的数字(用空格隔开).</p>
<p>  分析：<br>  对于num,通过num % 10可获取其最低位digit(个位)<br>  然后通过num &#x2F;&#x3D; 10将num整体向右移一位,这样最低位的前一位(十位)就变成了最低位,再通过num % 10即可该位.<br>  因此,只需重复上述过程直至num为0即可获得num的每一位数字.可使用循环描述该过程,属于条件控制的循环.<br>  上述的分析过程类似于<u>数学归纳法</u>,分析使用循环处理的问题时都可以采用该方法</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(num)</span><br><span class="line">&#123;</span><br><span class="line">    digit = num % <span class="number">10</span>;</span><br><span class="line">    num /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可写为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(; num; num /= <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    digit = num % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for和while语句表示的循环都属于当型循环(先判断条件再执行循环体),两者是等价的,因此不必刻意区分该循环是计数控制循环还是条件控制循环.</p>
</li>
<li><p>而do-while循环属于直到型循环:先执行循环体,再判断条件.do-while的实用性远不如for和while,其适用于至少执行一次循环的情况.</p>
</li>
</ul>
</li>
<li><p>辅助循环的跳转控制语句</p>
<ul>
<li>goto语句<br>该语句更倾向于底层语言.其容易造成不必要的混乱,因此谨慎使用或者放弃使用.</li>
</ul>
<p> C语言中更多使用的是由goto语句的特殊形式:<br> break语句和continue语句.</p>
<ul>
<li>break语句<br>通常与if搭配使用,在特定条件下跳出本层循环.用于结束本次循环<br>switch case语句中单独使用表示跳出当前分支</li>
<li>continue语句<br>通常与if搭配使用,在特定条件下跳转至循环体的末尾.用于于跳过本次循环,开始下一次循环.</li>
</ul>
</li>
</ul>
<h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><p> 在实际应用中,经常需要在循环体中再嵌入若干个循环以形成<strong>多层循环</strong>.这种多层循环就是嵌套循环.</p>
<ul>
<li>嵌套循环的执行过程:<br> 该过程可理解为从最外层到最内层,循环的优先级逐级增加:<br> 最外层循环的优先级最低,最内层的优先级最高.<br> 因此多层循环的执行时先由外层进入内层,在内层循环全部执行完成后再执行外层.<br> 因此外层循环就像从全局角度进行整体感知,而内层循环则是上负责每一个部分的具体实现.</li>
</ul>
<p>实践出真知,对于反馈性极强的编程自然也不例外,可以通过练习加深对循环过程的理解:</p>
<ul>
<li><p>输入一个数字n,计算从1到n每一个数字的阶乘和<br>  分析：</p>
<ul>
<li>阶乘和是将每一个数字的阶乘相加后可得到结果,这是一个累加的过程.因此可用外层循环表示将n个数字的阶乘相加</li>
<li>具体到每一个数字阶乘计算:计算该数字的阶乘是一个累乘的过程,因此用内层循环计算每个数字的阶乘</li>
</ul>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;  <span class="comment">// 最终的阶乘和</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> fact = <span class="number">1</span>; <span class="comment">// 每一个数字的阶乘</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;= i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        fact *= j;</span><br><span class="line">    &#125;</span><br><span class="line">    sum += fact;</span><br><span class="line">    fact = <span class="number">1</span>;       <span class="comment">//重置fact以计算下一个数字的阶乘</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%I64d\n&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>输入一个数字n,输出相应的金字塔图案<br>  样例输入(Sample Input):</p>
  <blockquote>5</blockquote>


<p>  样例输出(Sample Output):</p>
  <blockquote>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ABA<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ABCBA<br>
  &nbsp;&nbsp;&nbsp;ABCDCBA<br>
      ABCDEDCBA</blockquote>

      
<p>  分析:</p>
<ul>
<li>外层循环表示每一行的输出:<br>  先输出该行的图案,然后再输出换行符 共输出n行</li>
<li>内层循环表示当前行每一列的输出：<br>  (1) 先输出空格,第i行输出n-i个空格<br>  (2) 再输出字母,同一行中的所有字母都是对称的:<br>  第i行输出2*i-1个字母,第i行的对称中心为第i列,对称中心处的字母为&#39;A&#39;+i-1<br>  先从A开始顺序输出i个字母,再从对称中心处的字母开始逆序输出i-1个字母  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n - i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 顺序输出字母</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span> + j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逆序输出字母</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span> + i - <span class="number">1</span> - j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  根据对称性可将输出字母部分的代码进行简化:<br>  第j列的字母与其到对称中心(第i列)的距离abs(j-i)有关<br>  第j列应输出的字母为&#39;A&#39;+i-1-abs(j-i)  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输出空格</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n - i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出字母</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * i - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span> + i - <span class="number">1</span> - <span class="built_in">abs</span>(j - i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  该题可进一步升级为菱形<br>  样例输入(Sample Input):    <pre> 5 
  </pre>     
  样例输出(Sample Output):</li>
</ul>
  <pre>      A
     ABA
    ABCBA
   ABCDCBA
  ABCDEDCBA
   ABCDCBA
    ABCBA
     ABA
      A</pre>


<p>  菱形共输出2n-1行,并且对称中心为第n行.  </p>
<p>  到对称中心距离相等的两行是对称的,输出相同的图案.  </p>
<p>  第k行和倒数第k行就相当于金字塔图案中的第k行,如何使用i描述k?<br>  当前行为第i行,到对称中心的距离为abs(i-n),其相当于第金字塔团案中的第n-abs(i - n)行,因此k&#x3D;n-abs(i-n)<br>  因此使用k替代金字塔图案代码中外层循环体内的i即可</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k, l;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        k = n - <span class="built_in">abs</span>(i - n);</span><br><span class="line">        <span class="comment">// 使用k取代i</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n - k ; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * k - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span> + k - <span class="number">1</span> - <span class="built_in">abs</span>(j - k));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Programming Language</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>表达式求值(Expression Evaluation)</title>
    <url>/2022/10/24/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>机器很难处理我们平时使用的中缀表达式(运算符位于操作数中间),因需要对其进行优先级的判定.而后缀表达式(逆波兰表达式)无需考虑运算符的优先级,只需按照运算符从左到右的出现顺序依次进行运算,即可得到表达式的值.</p>
<blockquote>
<p>中缀表达式5*(6&#x2F;2+7)的后缀表达式为 6 2 &#x2F; 7 + 5 *</p>
</blockquote>
<p>由Dijkstra提出的<a href="%22https://zh.wikipedia.org/wiki/%E8%B0%83%E5%BA%A6%E5%9C%BA%E7%AE%97%E6%B3%95%22%3E">调度场算法(Shunting Yard Algorithm)</a>,可将中缀表达式转换为后缀表达式.该算法使用一个栈存储表达式中的运算符,其基本过程为:</p>
<ul>
<li>遇到运算数,将其添加到后缀表达式中.</li>
<li>遇到运算符,先进行运算条件的判断,运算条件为:<br><u>运算符栈非空并且栈顶运算符的优先级不低于当前运算符的优先级</u>                       <ul>
<li>满足运算条件<br>将栈顶运算符弹出后添加到后缀表达式中(表示执行了一次运算).继续判断运算条件,若满足运算条件则重复上述过程,直至不满足运算条件.</li>
<li>不满足运算条件<br>将当前运算符压入运算符栈.</li>
</ul>
</li>
</ul>
<p>完成表达式的遍历后,栈内可能仍存在运算符.将这些剩余的运算符依次从栈顶弹出,并且添加到后缀表达式中(表示依次执行这些栈顶运算符的运算).最终得到后缀表达式将其输出.<br>对该算法进行一些改进,便可实现表达式的求值.</p>
<h2 id="改进内容"><a href="#改进内容" class="headerlink" title="改进内容"></a>改进内容</h2><p>  对调度场算法(Shunting Yard Algorithm)的改进体现在两个方面：</p>
<ul>
<li>增加一个存储运算数的栈,遇到运算数时直接将其压入栈中  </li>
<li>具体实现弹出栈顶运算符时的运算  <ul>
<li>遇到运算符并且满足运算条件时,执行一次运算:根据栈顶运算符的目数, 从运算数栈中弹出相应数量的运算数进行相应的计算, 再将计算结果压入运算数栈中, 最后弹出栈顶运算符,表示本次运算结束.                 </li>
<li>表达式读取完成后, 栈中可能存在剩余元素(此时从栈顶到栈底运算符的优先级依次递减,栈非空时始终满足运算条件), 因此依次对剩余运算符进行运算,直至运算符栈为空.</li>
</ul>
</li>
</ul>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ol>
<li><p>处理表达式</p>
<ul>
<li>判断表达式是否有效(当前仅实现括号匹配的检测)<br>使用一个栈btk存储左括号<br>遇到左括号,其直接入栈<br>遇到右括号,检测与栈顶的左括号是否匹配.<br>  匹配方式为两者在pairs中对应的值互为相反数.<br>读取完表达式后,还要检测左括号栈是否为空,若栈非空,表明存在多余的左括号,表达式无效. <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string expr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt;check;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; pairs = </span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;(&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;)&#x27;</span>, <span class="number">-1</span>&#125;, </span><br><span class="line">        &#123;<span class="string">&#x27;[&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;]&#x27;</span>, <span class="number">-2</span>&#125;, </span><br><span class="line">        &#123;<span class="string">&#x27;&#123;&#x27;</span>, <span class="number">3</span>&#125;, &#123;<span class="string">&#x27;&#125;&#x27;</span>, <span class="number">-3</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; expr.<span class="built_in">length</span>() &amp;&amp; expr[i] != <span class="string">&#x27;=&#x27;</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//出现括号</span></span><br><span class="line">        <span class="keyword">if</span>(pairs.<span class="built_in">count</span>(expr[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> bkt = expr[i];</span><br><span class="line">            <span class="type">int</span> val = pairs[bkt];</span><br><span class="line">            <span class="keyword">if</span>(pairs[bkt] &gt; <span class="number">0</span>)  <span class="comment">// 左括号</span></span><br><span class="line">            &#123;</span><br><span class="line">                check.<span class="built_in">push</span>(bkt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                <span class="comment">// 右括号</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 当前右括号与栈顶左括号匹配</span></span><br><span class="line">                <span class="keyword">if</span>(!check.<span class="built_in">empty</span>() &amp;&amp; val == -pairs[check.<span class="built_in">top</span>()]) </span><br><span class="line">                &#123;</span><br><span class="line">                    check.<span class="built_in">pop</span>();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">// 当前右括号与栈顶右括号不匹配</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取完表达式 若栈中仍存在左括号, 则不匹配</span></span><br><span class="line">    <span class="keyword">return</span> check.<span class="built_in">empty</span>()? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>去除表达式expr中的空格 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">eraseSpace</span><span class="params">(string&amp; expr)</span>        </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = expr.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>); i != string::npos; i = expr.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>, i))</span><br><span class="line">    &#123;</span><br><span class="line">        expr.<span class="built_in">erase</span>(i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>提取表达式中的数字 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">extractNumFromexpr</span><span class="params">(string expr, <span class="type">int</span>&amp; i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string nums;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(expr[i]))</span><br><span class="line">    &#123;</span><br><span class="line">        nums += expr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(expr[i] == <span class="string">&#x27;.&#x27;</span>)  <span class="comment">//考虑小数的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        nums += expr[i++];</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(expr[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            nums += expr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stod</span>(nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>识别运算符     </p>
<ul>
<li>获取运算符的属性:<br>  包括运算符的优先级和元数(元数也称为目数,即运算符所需运算对象的个数)<br>使用无序关联容器unordered_map建立运算符与优先级&#x2F;目数的映射.对于每一个键值对:key为运算符,value为该运算符的优先级&#x2F;目数.<br>  (也可用struct表示运算符,运算符的优先级与目数作为其成员, 然后编写函数根据运算符的名称获取其属性).</li>
</ul>
<p>  判断表达式有效后,在表达式的求值函数(后文的calculate)中创建一个字符串opr记录表达式中所有可能出现的运算符.<br>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">opr</span><span class="params">(<span class="string">&quot;+-*/%^!(\&#x27;)[\\]&#123;|&#125;&quot;</span>)</span></span>;   </span><br></pre></td></tr></table></figure><br>  然后将opr分别传给getPrecedence和getArity获取这些运算符的属性.</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; precedence;  <span class="comment">// 存储运算符的优先级</span></span><br><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; arity;       <span class="comment">// 存储运算符的元数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPrecedence</span><span class="params">(<span class="type">const</span> string &amp;tokens)</span>      </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> opr : tokens)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opr)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            precedence[opr] = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">            precedence[opr] = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>: precedence[opr] = <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;!&#x27;</span>: precedence[opr] = <span class="number">4</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">            precedence[opr] = <span class="number">5</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\&#x27;&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:  <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">            precedence[opr] = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getArity</span><span class="params">(<span class="type">const</span> string &amp;tokens)</span>           </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> opr : tokens)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">                arity[opr] = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;!&#x27;</span>:</span><br><span class="line">                arity[opr] = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;\&#x27;&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:  <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                arity[opr] = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>执行运算符所对应的运算</p>
<p>对于二元运算符,根据栈先进后出的特性, 应注意运算数出现的次序:</p>
<ul>
<li>后出栈的为被减数&#x2F;被除数&#x2F;底数</li>
<li>先出栈的为&#x2F;减数&#x2F;除数&#x2F;指数</li>
</ul>
</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">performOp</span><span class="params">(<span class="type">char</span> op)</span>  <span class="comment">//根据运算符执行相应的运算</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arity[op] == <span class="number">2</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> num1, num2;</span><br><span class="line">        num1 = nums.<span class="built_in">top</span>(), nums.<span class="built_in">pop</span>();</span><br><span class="line">        num2 = nums.<span class="built_in">top</span>(), nums.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">switch</span>(op)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> num2 + num1;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> num2 - num1;     <span class="comment">//num2为被减数,num1为减数</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">return</span> num2 * num1;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">return</span> num2 / num1;     <span class="comment">//num2为被除数,num1为除数</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>: <span class="keyword">return</span> <span class="built_in">int</span>(num2) % <span class="built_in">int</span>(num1);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>: <span class="keyword">return</span> <span class="built_in">pow</span>(num2, num1); <span class="comment">//num2为底数,num1为指数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(arity[op] == <span class="number">1</span>) <span class="comment">//阶乘运算</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> num = nums.<span class="built_in">top</span>(), val = <span class="number">1</span>;</span><br><span class="line">        nums.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(; num &gt; <span class="number">1</span>; num--)</span><br><span class="line">        &#123;</span><br><span class="line">            val *= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>求表达式的值<br>  完成对表达式的处理和运算符的识别后,计算有效表达式的值.<br>  首先对表达式进行遍历<br>  (1) 读取到数字时<br> 调用函数extractNumFromexpr提取相应的运算数, 然后将其压入运算数栈nums中.<br> 当运算数为负数时,会出现负号’-‘,并非运算符减号.因此需要对表达式中的的负数进行特殊处理.<br> 处理方法为提前向运算数栈nums中压入一个0,从而将该负数转换为0与其绝对值进行一次减法运算,再将该负数的绝对值入栈.</p>
<p> 根据负号出现的位置分两种情况处理:</p>
<ul>
<li>负数出现在表达式开始处(第一个运算数为负数):开始运算前先将0压入运算数栈.</li>
<li>负数出现在表达式中间或结尾处(括号中出现负数):读取到左括号时先将0压入运算数栈,再将左括号压入运算符栈ops中.</li>
</ul>
<p>(2) 读取到运算符时</p>
<ul>
<li>如果为算术运算符,先判断是否满足运算条件<ul>
<li>若满足运算条件,则进行”改进内容”中的一次运算,该过程为:<br>根据栈顶运算符, 从运算数栈中弹出相应数量的运算数进行相应的计算,再将计算结果压入运算数栈中, 最后弹出栈顶运算符,表示本次运算结束.<br>继续进行运算条件的判断,满足运算条件则重复执行上述运算过程,直至不满足运算条件.</li>
<li>若不满足运算条件,则将当前运算符压入运算符栈ops中.</li>
</ul>
</li>
<li>如果为括号,需要将左括号与右括号分开处理   <ul>
<li>对于左括号,表示将在括号内进行一段子运算,因此在整个表达式中,其优先级最高.直接将其压入运算符栈,可合并到不满足运算条件的情况中.但左括号入栈后,表示正在进行括号内的运算,因此入栈后的左括号的优先级变为最低.<br>可采用如下方法,实现左括号入栈后优先级由最高变为最低:将ASCII码表中与左括号相邻的符号压入栈中,表示左括号入栈后优先级发生变化(左小括号用单引号’&#39;‘;左中括号用斜杠’\‘;左大括号用’|’).        </li>
<li>对于右括号,表示当前括号内的表达式已经完成读取,将其优先级设置为最低,这样即可完成括号内剩余的运算:进行栈顶运算符对应的运算然后将其依次弹出,直至遇到左括号.此时结束括号的运算.可将完成括号内剩余运算的过程合并到读取到算术运算符时满足运算条件的情况中.但不同的是左括号出栈时直接结束运算并且右括号不入栈.</li>
</ul>
</li>
</ul>
<p>  表达式读取完成后,运算符栈ops中可能仍存在剩余元素,因此需完成这些剩余运算.完成所有运算后,运算数栈nums中仅剩的栈顶元素即为表达式的值.</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">(string &amp;expr)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">eraseSpace</span>(expr);                      <span class="comment">//去除表达式中的空格</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isValid</span>(expr))                     <span class="comment">//表达式无效</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Invalid Expression&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">opr</span><span class="params">(<span class="string">&quot;+-*/%^!(\&#x27;)[\\]&#123;|&#125;&quot;</span>)</span></span>;      <span class="comment">//所有可能出现的运算符</span></span><br><span class="line">    <span class="built_in">getPrecedence</span>(opr), <span class="built_in">getArity</span>(opr);</span><br><span class="line">    <span class="comment">//负数出现在表达式开头</span></span><br><span class="line">    <span class="keyword">if</span>(expr[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)    </span><br><span class="line">    &#123;</span><br><span class="line">        nums.<span class="built_in">push</span>(<span class="number">0</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历表达式expr</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; expr.<span class="built_in">length</span>() &amp;&amp; expr[i] != <span class="string">&#x27;=&#x27;</span>; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(expr[i]))        <span class="comment">//读取到数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            nums.<span class="built_in">push</span>(<span class="built_in">extractNumFromexpr</span>(expr, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                            </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> currOp = expr[i];  <span class="comment">//读取到运算符,使用currOp记录当前运算符</span></span><br><span class="line">            <span class="comment">//满足运算条件,执行一次运算                </span></span><br><span class="line">            <span class="keyword">while</span>(!ops.<span class="built_in">empty</span>() &amp;&amp; precedence[ops.<span class="built_in">top</span>()] &gt;= precedence[expr[i]])   </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//栈顶运算符为算术运算符</span></span><br><span class="line">                <span class="keyword">if</span>(arity[ops.<span class="built_in">top</span>()])                     </span><br><span class="line">                &#123;</span><br><span class="line">                    nums.<span class="built_in">push</span>(<span class="built_in">performOp</span>(ops.<span class="built_in">top</span>())), ops.<span class="built_in">pop</span>();                           </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当前的运算符为右括号,且栈顶运算符为左括号</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ops.<span class="built_in">pop</span>();  <span class="comment">//将左括号从运算符栈中弹出</span></span><br><span class="line">                    <span class="keyword">break</span>;          <span class="comment">//此时已经完成括号内的运算,跳出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前运算符为左括号</span></span><br><span class="line">            <span class="keyword">if</span>(currOp == <span class="string">&#x27;(&#x27;</span> || currOp == <span class="string">&#x27;[&#x27;</span> || currOp == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//对左括号进行处理已使入栈后优先级变为最低</span></span><br><span class="line">                currOp == <span class="string">&#x27;(&#x27;</span> ? currOp-- : currOp++;</span><br><span class="line">                <span class="keyword">if</span>(expr[i + <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>)  </span><br><span class="line">                &#123;</span><br><span class="line">                    nums.<span class="built_in">push</span>(<span class="number">0</span>);   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右括号不入栈</span></span><br><span class="line">            <span class="keyword">if</span>(!(currOp == <span class="string">&#x27;)&#x27;</span> || currOp == <span class="string">&#x27;]&#x27;</span> || currOp == <span class="string">&#x27;&#125;&#x27;</span>))  </span><br><span class="line">            &#123;</span><br><span class="line">                ops.<span class="built_in">push</span>(currOp);                               </span><br><span class="line">            &#125;</span><br><span class="line">            i++;                       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表达式读取完成,栈内可能仍存在运算符,依次完成剩余运算符的运算</span></span><br><span class="line">    <span class="keyword">while</span>(!ops.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        nums.<span class="built_in">push</span>(<span class="built_in">performOp</span>(ops.<span class="built_in">top</span>())), ops.<span class="built_in">pop</span>();                            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 运算数栈仅剩的栈顶元素即为表达式的值</span></span><br><span class="line">    cout&lt;&lt; nums.<span class="built_in">top</span>() &lt;&lt;endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>完整代码 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calcultor</span></span><br><span class="line">&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; ops;                      <span class="comment">//存储运算符</span></span><br><span class="line">    stack&lt;<span class="type">double</span>&gt; nums;                   <span class="comment">//存储运算数</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; precedence;  <span class="comment">// 存储运算符的优先级</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; arity;       <span class="comment">// 存储运算符的元数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eraseSpace</span><span class="params">(string&amp; expr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = expr.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>); i != string::npos; i = expr.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>, i))</span><br><span class="line">        &#123;</span><br><span class="line">            expr.<span class="built_in">erase</span>(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string expr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt;check;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; pairs =</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;<span class="string">&#x27;(&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;)&#x27;</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;[&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;]&#x27;</span>, <span class="number">-2</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;&#123;&#x27;</span>, <span class="number">3</span>&#125;, &#123;<span class="string">&#x27;&#125;&#x27;</span>, <span class="number">-3</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; expr.<span class="built_in">length</span>() &amp;&amp; expr[i] != <span class="string">&#x27;=&#x27;</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//出现括号</span></span><br><span class="line">            <span class="keyword">if</span>(pairs.<span class="built_in">count</span>(expr[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> bkt = expr[i];</span><br><span class="line">                <span class="type">int</span> val = pairs[bkt];</span><br><span class="line">                <span class="keyword">if</span>(pairs[bkt] &gt; <span class="number">0</span>)  <span class="comment">// 左括号</span></span><br><span class="line">                &#123;</span><br><span class="line">                    check.<span class="built_in">push</span>(bkt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>                <span class="comment">// 右括号</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 当前右括号与栈顶左括号匹配</span></span><br><span class="line">                    <span class="keyword">if</span>(!check.<span class="built_in">empty</span>() &amp;&amp; val == -pairs[check.<span class="built_in">top</span>()])</span><br><span class="line">                    &#123;</span><br><span class="line">                        check.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 当前右括号与栈顶右括号不匹配</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读取完表达式 栈中仍存在左括号, 则不匹配</span></span><br><span class="line">        <span class="keyword">return</span> check.<span class="built_in">empty</span>()? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getPrecedence</span><span class="params">(<span class="type">const</span> string &amp;tokens)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> opr : tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (opr)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                precedence[opr] = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">                precedence[opr] = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>: precedence[opr] = <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;!&#x27;</span>: precedence[opr] = <span class="number">4</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                precedence[opr] = <span class="number">5</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\&#x27;&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:  <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                precedence[opr] = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getArity</span><span class="params">(<span class="type">const</span> string &amp;tokens)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> opr : tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (opr)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">                    arity[opr] = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;!&#x27;</span>:</span><br><span class="line">                    arity[opr] = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;\&#x27;&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:  <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                    arity[opr] = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">extractNumFromexpr</span><span class="params">(string expr, <span class="type">int</span>&amp; i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string nums;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(expr[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            nums += expr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(expr[i] == <span class="string">&#x27;.&#x27;</span>)  <span class="comment">//考虑小数的情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            nums += expr[i++];</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isdigit</span>(expr[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                nums += expr[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stod</span>(nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">performOp</span><span class="params">(<span class="type">char</span> op)</span>  <span class="comment">//执行一次运算</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arity[op] == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> num1, num2;</span><br><span class="line">            num1 = nums.<span class="built_in">top</span>(), nums.<span class="built_in">pop</span>();</span><br><span class="line">            num2 = nums.<span class="built_in">top</span>(), nums.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">switch</span>(op)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> num2 + num1;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> num2 - num1;     <span class="comment">//num2为被减数,num1为减数</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">return</span> num2 * num1;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">return</span> num2 / num1;     <span class="comment">//num2为被除数,num1为除数</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>: <span class="keyword">return</span> <span class="built_in">int</span>(num2) % <span class="built_in">int</span>(num1);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>: <span class="keyword">return</span> <span class="built_in">pow</span>(num2, num1); <span class="comment">//num2为底数,num1为指数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arity[op] == <span class="number">1</span>) <span class="comment">//阶乘运算</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> num = nums.<span class="built_in">top</span>(), val = <span class="number">1</span>;</span><br><span class="line">            nums.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(; num &gt; <span class="number">1</span>; num--)</span><br><span class="line">            &#123;</span><br><span class="line">                val *= num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">(string &amp;expr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">eraseSpace</span>(expr);                      <span class="comment">//去除表达式中的空格</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isValid</span>(expr))                     <span class="comment">//表达式无效</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Invalid Expression&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">opr</span><span class="params">(<span class="string">&quot;+-*/%^!(\&#x27;)[\\]&#123;|&#125;&quot;</span>)</span></span>;      <span class="comment">//所有可能出现的运算符</span></span><br><span class="line">        <span class="built_in">getPrecedence</span>(opr), <span class="built_in">getArity</span>(opr);</span><br><span class="line">        <span class="comment">//负数出现在表达式开头</span></span><br><span class="line">        <span class="keyword">if</span>(expr[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nums.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历表达式expr</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; expr.<span class="built_in">length</span>() &amp;&amp; expr[i] != <span class="string">&#x27;=&#x27;</span>; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(expr[i]))        <span class="comment">//读取到数字</span></span><br><span class="line">            &#123;</span><br><span class="line">                nums.<span class="built_in">push</span>(<span class="built_in">extractNumFromexpr</span>(expr, i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> currOp = expr[i];  <span class="comment">//读取到运算符,使用currOp记录当前运算符</span></span><br><span class="line">                <span class="keyword">while</span>(!ops.<span class="built_in">empty</span>() &amp;&amp; precedence[ops.<span class="built_in">top</span>()] &gt;= precedence[expr[i]])    <span class="comment">//满足运算条件,执行一次运算</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//栈顶运算符为算术运算符</span></span><br><span class="line">                    <span class="keyword">if</span>(arity[ops.<span class="built_in">top</span>()])</span><br><span class="line">                    &#123;</span><br><span class="line">                        nums.<span class="built_in">push</span>(<span class="built_in">performOp</span>(ops.<span class="built_in">top</span>())), ops.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//当前的运算符为右括号,且栈顶运算符为左括号</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        ops.<span class="built_in">pop</span>();  <span class="comment">//将左括号从运算符栈中弹出</span></span><br><span class="line">                        <span class="keyword">break</span>;          <span class="comment">//此时已经完成括号内的运算,跳出循环</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前运算符为左括号</span></span><br><span class="line">                <span class="keyword">if</span>(currOp == <span class="string">&#x27;(&#x27;</span> || currOp == <span class="string">&#x27;[&#x27;</span> || currOp == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//对左括号进行处理已使入栈后优先级变为最低</span></span><br><span class="line">                    currOp == <span class="string">&#x27;(&#x27;</span> ? currOp-- : currOp++;</span><br><span class="line">                    <span class="keyword">if</span>(expr[i + <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        nums.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//此时不满足运算条件或者结束了括号内的子运算</span></span><br><span class="line">                <span class="keyword">if</span>(!(currOp == <span class="string">&#x27;)&#x27;</span> || currOp == <span class="string">&#x27;]&#x27;</span> || currOp == <span class="string">&#x27;&#125;&#x27;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    ops.<span class="built_in">push</span>(currOp);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//表达式读取完成,栈内可能仍存在运算符,依次完成剩余运算符的运算</span></span><br><span class="line">        <span class="keyword">while</span>(!ops.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            nums.<span class="built_in">push</span>(<span class="built_in">performOp</span>(ops.<span class="built_in">top</span>())), ops.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 运算数栈仅剩的栈顶元素即为表达式的值</span></span><br><span class="line">        cout &lt;&lt; nums.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string expr;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin, expr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Calcultor</span>().<span class="built_in">calculate</span>(expr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
</search>
