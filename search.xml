<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>表达式求值</title>
    <url>/2022/10/24/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    <content><![CDATA[<h1 id="表达式求值-Expression-Evaluation"><a href="#表达式求值-Expression-Evaluation" class="headerlink" title="表达式求值(Expression Evaluation)"></a>表达式求值(Expression Evaluation)</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>机器很难处理人类所使用的中缀表达式(运算符位于操作数中间),因其需要进行优先级的判定.而后缀表达式(逆波兰表达式)无需考虑运算符的优先级, 只需按照运算符从左到右的出现顺序进行运算,即可得到表达式的值,因而便于计算机进行处理.</p>
<blockquote>
<p>中缀表达式5*(6&#x2F;2+7)的后缀表达式为 6 2 &#x2F; 7 + 5 *</p>
</blockquote>
<p>由Dijkstra提出的<a href="%22https://zh.wikipedia.org/wiki/%E8%B0%83%E5%BA%A6%E5%9C%BA%E7%AE%97%E6%B3%95%22%3E">调度场算法(Shunting Yard Algorithm)</a>,用于将中缀表达式转换为后缀表达式.该算法使用一个栈存储表达式中的运算符.该算法的基本过程为:</p>
<ul>
<li>遇到运算数,将其添加到后缀表达式中.</li>
<li>遇到运算符,先进行运算条件的判断.运算条件为:<br><u>运算符栈非空并且栈顶运算符的优先级不低于当前运算符的优先级</u>                       <ul>
<li>满足运算条件<br>栈顶的运算符弹出并且添加到后缀表达式中并(表示执行了一次运算).继续判断运算条件(若满足,则重复上述过程),直至不满足运算条件</li>
<li>不满足运算条件<br>将当前运算符压入栈中</li>
</ul>
</li>
</ul>
<p>完成表达式的遍历后,栈内可能仍存在运算符.将这些剩余的运算符依次从栈顶弹出,并且添加到后缀表达式中(表示依次执行这些栈顶运算符的运算).最终得到后缀表达式将其输出.<br>对该算法进行一些<em>改进</em>,即在弹出运算符时实现”<em>执行一次运算</em>“,即可求解表达式的值,从而可以实现一个简易的计算器.</p>
<h2 id="改进内容"><a href="#改进内容" class="headerlink" title="改进内容"></a>改进内容</h2><p>  对调度场算法(Shunting Yard Algorithm)进行改进体现在两个方面：</p>
<ul>
<li>增加一个栈存储运算符,遇到运算数直接将其入栈.  </li>
<li>具体实现”执行一次运算”的操作   <ul>
<li>遇到运算符并且满足运算条件时,执行一次运算:在弹出栈顶运算符前,根据栈顶运算符的目数, 从运算数栈中弹出相应数量的运算数进行运算, 然后将运算结果压入运算数栈)                 </li>
<li>表达式读取完成后, 栈中存在剩余运算符(此时从栈顶到栈底运算符的优先级依次递减), 依次对这些运算符执行与1)相同的运算:根据栈顶运算符的目数, 从运算数栈中弹出相应数量的运算数完成一次运算, 并且将运算结果压入运算数栈中,然后弹出栈顶运算符.</li>
</ul>
</li>
</ul>
<p>最终运算数栈中仅剩的栈顶元素即为表达式的值.</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ol>
<li><p>表达式的处理</p>
<ul>
<li>判断表达式是否有效(暂时仅实现括号匹配的检测)<br>使用一个栈btk存储左括号<ul>
<li>遇到左括号直接入栈</li>
<li>遇到右括号检测是否与栈顶的左括号匹配.<br>  匹配方式为两者pairs中对应的值互为相反数.<br>读取完表达式后,检测左括号栈是否为空,若非空,表明存在多余的左括号. <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string expr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt;check;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; pairs = </span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;(&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;)&#x27;</span>, <span class="number">-1</span>&#125;, </span><br><span class="line">        &#123;<span class="string">&#x27;[&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;]&#x27;</span>, <span class="number">-2</span>&#125;, </span><br><span class="line">        &#123;<span class="string">&#x27;&#123;&#x27;</span>, <span class="number">3</span>&#125;, &#123;<span class="string">&#x27;&#125;&#x27;</span>, <span class="number">-3</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; expr.<span class="built_in">length</span>() &amp;&amp; expr[i] != <span class="string">&#x27;=&#x27;</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//出现括号</span></span><br><span class="line">        <span class="keyword">if</span>(pairs.<span class="built_in">count</span>(expr[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> bkt = expr[i];</span><br><span class="line">            <span class="type">int</span> val = pairs[bkt];</span><br><span class="line">            <span class="keyword">if</span>(pairs[bkt] &gt; <span class="number">0</span>)  <span class="comment">// 左括号</span></span><br><span class="line">            &#123;</span><br><span class="line">                check.<span class="built_in">push</span>(bkt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                <span class="comment">// 右括号</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 当前右括号与栈顶左括号匹配</span></span><br><span class="line">                <span class="keyword">if</span>(!check.<span class="built_in">empty</span>() &amp;&amp; val == -pairs[check.<span class="built_in">top</span>()]) </span><br><span class="line">                &#123;</span><br><span class="line">                    check.<span class="built_in">pop</span>();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">// 当前右括号与栈顶右括号不匹配</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取完表达式 栈中仍存在左括号, 则不匹配</span></span><br><span class="line">    <span class="keyword">return</span> check.<span class="built_in">empty</span>()? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>去除表达式expr中的空格 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">eraseSpace</span><span class="params">(string&amp; expr)</span>        </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = expr.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>); i != string::npos; i = expr.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>, i))</span><br><span class="line">    &#123;</span><br><span class="line">        expr.<span class="built_in">erase</span>(i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>提取表达式中的数字 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">extractNumFromexpr</span><span class="params">(string expr, <span class="type">int</span>&amp; i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string nums;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(expr[i]))</span><br><span class="line">    &#123;</span><br><span class="line">        nums += expr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(expr[i] == <span class="string">&#x27;.&#x27;</span>)  <span class="comment">//考虑小数的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        nums += expr[i++];</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(expr[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            nums += expr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stod</span>(nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>运算符的识别      </p>
<ul>
<li><p>获取运算符的属性:<br>  优先级以及运算符的元数(元数即所需运算对象的个数)<br>使用无序关联容器unordered_map建立运算符与优先级&#x2F;目数的映射,对于每一个键值对:key为运算符,value为该运算符的优先级目数.<br>  也可以用struct表示一个运算符,使用函数根据运算符的名称获取其属性.</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; precedence;  <span class="comment">// 存储运算符的优先级</span></span><br><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; arity;       <span class="comment">// 存储运算符的元数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initPrecedence</span><span class="params">(<span class="type">const</span> string &amp;tokens)</span>      </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> opr : tokens)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opr)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            precedence[opr] = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">            precedence[opr] = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>: precedence[opr] = <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;!&#x27;</span>: precedence[opr] = <span class="number">4</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">            precedence[opr] = <span class="number">5</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\&#x27;&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:  <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">            precedence[opr] = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initArity</span><span class="params">(<span class="type">const</span> string &amp;tokens)</span>           </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> opr : tokens)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">                arity[opr] = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;!&#x27;</span>:</span><br><span class="line">                arity[opr] = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;\&#x27;&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:  <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                arity[opr] = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 判断表达式有效后,对表达式计算的函数(后文的calculate)中创建一个字符串记录所有可能出现的运算符,然后分别传给initPrecedence、initArity获取这些运算符的属性.</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">opr</span><span class="params">(<span class="string">&quot;+-*/%^!(\&#x27;)[\\]&#123;|&#125;&quot;</span>)</span></span>;   <span class="comment">//记录所有可能出现的运算符</span></span><br></pre></td></tr></table></figure></li>
<li><p>根据运算符执行相应的运算</p>
<p>对于二元运算符,根据栈先进后出的特性, 应注意运算数出现的次序:</p>
<ul>
<li>后出栈的为被减数&#x2F;被除数&#x2F;底数</li>
<li>先出栈的为&#x2F;减数&#x2F;除数&#x2F;指数</li>
</ul>
</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">performOp</span><span class="params">(<span class="type">char</span> op)</span>  <span class="comment">//执行一次运算</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arity[op] == <span class="number">2</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> num1, num2;</span><br><span class="line">        num1 = nums.<span class="built_in">top</span>(), nums.<span class="built_in">pop</span>();</span><br><span class="line">        num2 = nums.<span class="built_in">top</span>(), nums.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">switch</span>(op)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> num2 + num1;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> num2 - num1;     <span class="comment">//num2为被减数,num1为减数</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">return</span> num2 * num1;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">return</span> num2 / num1;     <span class="comment">//num2为被除数,num1为除数</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>: <span class="keyword">return</span> <span class="built_in">int</span>(num2) % <span class="built_in">int</span>(num1);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>: <span class="keyword">return</span> <span class="built_in">pow</span>(num2, num1); <span class="comment">//num2为底数,num1为指数</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(arity[op] == <span class="number">1</span>) <span class="comment">//阶乘运算</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> num = nums.<span class="built_in">top</span>(), val = <span class="number">1</span>;</span><br><span class="line">        nums.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(; num &gt; <span class="number">1</span>; num--)</span><br><span class="line">        &#123;</span><br><span class="line">            val *= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>求表达式的值<br>  完成对表达式的处理以及对运算符进行识别后,计算有效的表达式的值.<br>  首先对表达式进行遍历</p>
</li>
</ol>
<ul>
<li><p>读取到运算数时<br>调用函数extractNumFromexpr提取该运算数, 然后压入运算数栈nums中.<br>当运算数为负数时,此时出现的’-‘表示负号,并非运算符减号.因此对复出现的负数进行特殊处理.<br>处理方法为提前向运算数栈nums中压入一个0,从而将该负数转换为0与其绝对值进行一次减法运算.</p>
<p>根据负号出现的位置分两种情况处理:</p>
<ul>
<li>负数出现在表达式开始处(第一个运算数为负数):开始运算前先将0压入运算数栈中.</li>
<li>负数出现在表达式中间或结尾处(括号中出现负数):读取到左括号时先将0压入运算数栈中,再将左括号压入运算符栈.</li>
</ul>
</li>
<li><p>读取到运算符时</p>
<ul>
<li>如果为算术运算符,先判断是否满足运算条件<ul>
<li>若满足运算条件,将栈顶运算符弹出并且进行一次运算.然后重复进行上述过程,直至不满足运算条件.</li>
<li>若不满足运算条件,则直接将当前运算符压入运算符栈.</li>
</ul>
</li>
<li>如果为括号,需要将左括号与右括号分开处理   <ul>
<li>对于左括号,在整个表达式中,其优先级最高,直接将其压入运算符栈,可合并到不满足运算条件的情况.但入栈后,表示即将进行括号内的子运算,因此入栈后的左括号的优先级变为最低.<br> 可采用如下方法,实现左括号入栈后优先级由最高变为最低:将ASCII码表中与左括号相邻的符号压入栈中,表示左括号入栈后优先级发生变化.        </li>
<li>对于右括号,代表当前括号内的子表达式已经完成扫描.因此其优先级为最低,这样即可完成括号内剩余运算符的运算：将栈顶运算符依次弹出并且进行运算直至遇到左括号.可将其合并到满足运算条件进行运算的情况,但不同的是左括号出栈时直接结束需当前的运算并且右括号不入栈.<br> 表达式读取完成后,运算符栈内可能仍存在运算符,因此需完成这些剩余运算符的运算.</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">(string &amp;expr)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">eraseSpace</span>(expr);                      <span class="comment">//去除表达式中的空格</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isValid</span>(expr))                     <span class="comment">//表达式无效</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Invalid Expression&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">opr</span><span class="params">(<span class="string">&quot;+-*/%^!(\&#x27;)[\\]&#123;|&#125;&quot;</span>)</span></span>;      <span class="comment">//所有可能出现的运算符</span></span><br><span class="line">    <span class="built_in">initPrecedence</span>(opr), <span class="built_in">initArity</span>(opr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//负数出现在表达式开头</span></span><br><span class="line">    <span class="keyword">if</span>(expr[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)    </span><br><span class="line">    &#123;</span><br><span class="line">        nums.<span class="built_in">push</span>(<span class="number">0</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历表达式expr</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; expr.<span class="built_in">length</span>() &amp;&amp; expr[i] != <span class="string">&#x27;=&#x27;</span>; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(expr[i]))        <span class="comment">//读取到数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            nums.<span class="built_in">push</span>(<span class="built_in">extractNumFromexpr</span>(expr, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                            </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> currOp = expr[i];  <span class="comment">//读取到运算符,使用currOp记录当前运算符</span></span><br><span class="line">            <span class="comment">//满足运算条件,执行一次运算                </span></span><br><span class="line">            <span class="keyword">while</span>(!ops.<span class="built_in">empty</span>() &amp;&amp; precedence[ops.<span class="built_in">top</span>()] &gt;= precedence[expr[i]])   </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//栈顶运算符为算术运算符</span></span><br><span class="line">                <span class="keyword">if</span>(arity[ops.<span class="built_in">top</span>()])                     </span><br><span class="line">                &#123;</span><br><span class="line">                    nums.<span class="built_in">push</span>(<span class="built_in">performOp</span>(ops.<span class="built_in">top</span>())), ops.<span class="built_in">pop</span>();                           </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当前的运算符为右括号,且栈顶运算符为左括号</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ops.<span class="built_in">pop</span>();  <span class="comment">//将左括号从运算符栈中弹出</span></span><br><span class="line">                    <span class="keyword">break</span>;          <span class="comment">//此时已经完成括号内的运算,跳出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前运算符为左括号</span></span><br><span class="line">            <span class="keyword">if</span>(currOp == <span class="string">&#x27;(&#x27;</span> || currOp == <span class="string">&#x27;[&#x27;</span> || currOp == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//对左括号进行处理已使入栈后优先级变为最低</span></span><br><span class="line">                currOp == <span class="string">&#x27;(&#x27;</span> ? currOp-- : currOp++;</span><br><span class="line">                <span class="keyword">if</span>(expr[i + <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>)  </span><br><span class="line">                &#123;</span><br><span class="line">                    nums.<span class="built_in">push</span>(<span class="number">0</span>);   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右括号不入栈</span></span><br><span class="line">            <span class="keyword">if</span>(!(currOp == <span class="string">&#x27;)&#x27;</span> || currOp == <span class="string">&#x27;]&#x27;</span> || currOp == <span class="string">&#x27;&#125;&#x27;</span>))  </span><br><span class="line">            &#123;</span><br><span class="line">                ops.<span class="built_in">push</span>(currOp);                               </span><br><span class="line">            &#125;</span><br><span class="line">            i++;                       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表达式读取完成,栈内可能仍存在运算符,依次完成剩余运算符的运算</span></span><br><span class="line">    <span class="keyword">while</span>(!ops.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        nums.<span class="built_in">push</span>(<span class="built_in">performOp</span>(ops.<span class="built_in">top</span>())), ops.<span class="built_in">pop</span>();                            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 运算数栈仅剩的栈顶元素即为表达式的值</span></span><br><span class="line">    cout&lt;&lt; nums.<span class="built_in">top</span>() &lt;&lt;endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>完整代码 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calcultor</span></span><br><span class="line">&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; ops;                      <span class="comment">//存储运算符</span></span><br><span class="line">    stack&lt;<span class="type">double</span>&gt; nums;                   <span class="comment">//存储运算数</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; precedence;  <span class="comment">// 存储运算符的优先级</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; arity;       <span class="comment">// 存储运算符的元数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eraseSpace</span><span class="params">(string&amp; expr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = expr.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>); i != string::npos; i = expr.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>, i))</span><br><span class="line">        &#123;</span><br><span class="line">            expr.<span class="built_in">erase</span>(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string expr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt;check;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; pairs =</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;<span class="string">&#x27;(&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;)&#x27;</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;[&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;]&#x27;</span>, <span class="number">-2</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;&#123;&#x27;</span>, <span class="number">3</span>&#125;, &#123;<span class="string">&#x27;&#125;&#x27;</span>, <span class="number">-3</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; expr.<span class="built_in">length</span>() &amp;&amp; expr[i] != <span class="string">&#x27;=&#x27;</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//出现括号</span></span><br><span class="line">            <span class="keyword">if</span>(pairs.<span class="built_in">count</span>(expr[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> bkt = expr[i];</span><br><span class="line">                <span class="type">int</span> val = pairs[bkt];</span><br><span class="line">                <span class="keyword">if</span>(pairs[bkt] &gt; <span class="number">0</span>)  <span class="comment">// 左括号</span></span><br><span class="line">                &#123;</span><br><span class="line">                    check.<span class="built_in">push</span>(bkt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>                <span class="comment">// 右括号</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 当前右括号与栈顶左括号匹配</span></span><br><span class="line">                    <span class="keyword">if</span>(!check.<span class="built_in">empty</span>() &amp;&amp; val == -pairs[check.<span class="built_in">top</span>()])</span><br><span class="line">                    &#123;</span><br><span class="line">                        check.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 当前右括号与栈顶右括号不匹配</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读取完表达式 栈中仍存在左括号, 则不匹配</span></span><br><span class="line">        <span class="keyword">return</span> check.<span class="built_in">empty</span>()? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initPrecedence</span><span class="params">(<span class="type">const</span> string &amp;tokens)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> opr : tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (opr)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                precedence[opr] = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">                precedence[opr] = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>: precedence[opr] = <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;!&#x27;</span>: precedence[opr] = <span class="number">4</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                precedence[opr] = <span class="number">5</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\&#x27;&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:  <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                precedence[opr] = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initArity</span><span class="params">(<span class="type">const</span> string &amp;tokens)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> opr : tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (opr)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">                    arity[opr] = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;!&#x27;</span>:</span><br><span class="line">                    arity[opr] = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;\&#x27;&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:  <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                    arity[opr] = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">extractNumFromexpr</span><span class="params">(string expr, <span class="type">int</span>&amp; i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string nums;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(expr[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            nums += expr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(expr[i] == <span class="string">&#x27;.&#x27;</span>)  <span class="comment">//考虑小数的情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            nums += expr[i++];</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isdigit</span>(expr[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                nums += expr[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stod</span>(nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">performOp</span><span class="params">(<span class="type">char</span> op)</span>  <span class="comment">//执行一次运算</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arity[op] == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> num1, num2;</span><br><span class="line">            num1 = nums.<span class="built_in">top</span>(), nums.<span class="built_in">pop</span>();</span><br><span class="line">            num2 = nums.<span class="built_in">top</span>(), nums.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">switch</span>(op)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> num2 + num1;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> num2 - num1;     <span class="comment">//num2为被减数,num1为减数</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">return</span> num2 * num1;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">return</span> num2 / num1;     <span class="comment">//num2为被除数,num1为除数</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>: <span class="keyword">return</span> <span class="built_in">int</span>(num2) % <span class="built_in">int</span>(num1);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>: <span class="keyword">return</span> <span class="built_in">pow</span>(num2, num1); <span class="comment">//num2为底数,num1为指数</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arity[op] == <span class="number">1</span>) <span class="comment">//阶乘运算</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> num = nums.<span class="built_in">top</span>(), val = <span class="number">1</span>;</span><br><span class="line">            nums.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(; num &gt; <span class="number">1</span>; num--)</span><br><span class="line">            &#123;</span><br><span class="line">                val *= num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">(string &amp;expr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">eraseSpace</span>(expr);                      <span class="comment">//去除表达式中的空格</span></span><br><span class="line">        <span class="function">string <span class="title">opr</span><span class="params">(<span class="string">&quot;+-*/%^!(\&#x27;)[\\]&#123;|&#125;&quot;</span>)</span></span>;      <span class="comment">//所有可能出现的运算符</span></span><br><span class="line">        <span class="built_in">initPrecedence</span>(opr), <span class="built_in">initArity</span>(opr);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isValid</span>(expr))                     <span class="comment">//表达式无效</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Invalid Expression&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//负数出现在表达式开头</span></span><br><span class="line">        <span class="keyword">if</span>(expr[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nums.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历表达式expr</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; expr.<span class="built_in">length</span>() &amp;&amp; expr[i] != <span class="string">&#x27;=&#x27;</span>; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(expr[i]))        <span class="comment">//读取到数字</span></span><br><span class="line">            &#123;</span><br><span class="line">                nums.<span class="built_in">push</span>(<span class="built_in">extractNumFromexpr</span>(expr, i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> currOp = expr[i];  <span class="comment">//读取到运算符,使用currOp记录当前运算符</span></span><br><span class="line">                <span class="keyword">while</span>(!ops.<span class="built_in">empty</span>() &amp;&amp; precedence[ops.<span class="built_in">top</span>()] &gt;= precedence[expr[i]])    <span class="comment">//满足运算条件,执行一次运算</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//栈顶运算符为算术运算符</span></span><br><span class="line">                    <span class="keyword">if</span>(arity[ops.<span class="built_in">top</span>()])</span><br><span class="line">                    &#123;</span><br><span class="line">                        nums.<span class="built_in">push</span>(<span class="built_in">performOp</span>(ops.<span class="built_in">top</span>())), ops.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//当前的运算符为右括号,且栈顶运算符为左括号</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        ops.<span class="built_in">pop</span>();  <span class="comment">//将左括号从运算符栈中弹出</span></span><br><span class="line">                        <span class="keyword">break</span>;          <span class="comment">//此时已经完成括号内的运算,跳出循环</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前运算符为左括号</span></span><br><span class="line">                <span class="keyword">if</span>(currOp == <span class="string">&#x27;(&#x27;</span> || currOp == <span class="string">&#x27;[&#x27;</span> || currOp == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//对左括号进行处理已使入栈后优先级变为最低</span></span><br><span class="line">                    currOp == <span class="string">&#x27;(&#x27;</span> ? currOp-- : currOp++;</span><br><span class="line">                    <span class="keyword">if</span>(expr[i + <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        nums.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//此时不满足运算条件或者结束了括号内的子运算</span></span><br><span class="line">                <span class="keyword">if</span>(!(currOp == <span class="string">&#x27;)&#x27;</span> || currOp == <span class="string">&#x27;]&#x27;</span> || currOp == <span class="string">&#x27;&#125;&#x27;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    ops.<span class="built_in">push</span>(currOp);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//表达式读取完成,栈内可能仍存在运算符,依次完成剩余运算符的运算</span></span><br><span class="line">        <span class="keyword">while</span>(!ops.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            nums.<span class="built_in">push</span>(<span class="built_in">performOp</span>(ops.<span class="built_in">top</span>())), ops.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 运算数栈仅剩的栈顶元素即为表达式的值</span></span><br><span class="line">        cout &lt;&lt; nums.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string expr;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin, expr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Calcultor</span>().<span class="built_in">calculate</span>(expr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Programming</category>
        <category>[object Object]</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>调度场算法(Shunting Yard Algorithm)</title>
    <url>/2022/10/23/%E8%B0%83%E5%BA%A6%E5%9C%BA%E7%AE%97%E6%B3%95-Shunting-Yard-Algorithm/</url>
    <content><![CDATA[<h1 id="调度场算法"><a href="#调度场算法" class="headerlink" title="调度场算法"></a>调度场算法</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>调度场算法用于将中缀表达式转换为后缀表达式(逆波兰表达式).</p>
<span id="more"></span>
<blockquote>
<p>中缀表达式5*(6&#x2F;2+7)的后缀表达式为 6 2 &#x2F; 7 + 5 * </p>
</blockquote>
<p> 后缀表达式无需考虑运算符的优先级(不需要使用括号标识优先级),只需按照运算符从左到右的出现顺序进行运算,即可得到表达式的值,因此便于计算机对其进行识别处理.</p>
<h3 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h3><blockquote>
<p>使用一个栈存储表达式的运算符</p>
</blockquote>
<p>首先遍历待中缀表达式</p>
<ul>
<li>遇到运算数时,直接将其添加到后缀表达式中.</li>
<li>遇到运算符,运算条件为:<u>运算符栈非空并且栈顶运算符的优先级不低于当前运算符的优先级</u><ul>
<li>如果为算术运算符,先判断是否满足运算条件：                       <ul>
<li>满足运算条件<br>栈顶的运算符弹出并且添加到后缀表达式中并(表示执行了一次运算).继续判断运算条件(若满足,则重复上述过程),直至不满足运算条件</li>
<li>不满足运算条件<br>将当前运算符压入栈中</li>
</ul>
</li>
<li>如果为括号,需要分开处理：   <ul>
<li>对于左括号,表示将在括号内进行一段子运算,因此在整个表达式中,其优先级最高,直接将其压入运算符栈.可合并到(1)中不满足运算条件的情况.但入栈后,表示进行括号内的子运算,因此入栈后的左括号的优先级变为最低.<br> 可采用如下方法,实现左括号入栈后优先级由最高变为最低:将ASCII码表中与左括号相邻的符号压入栈中,表示左括号入栈后优先级发生变化.        </li>
<li>对于右括号,其优先级为最低, 表示当前括号内的表达式结束,因此其优先级为最低,这样即可完成括号内剩余运算符的运算：将栈顶运算符依次弹出并且进行运算直至遇到左括号.可将完成括号内剩余运算的情形合并到(1)中满足运算条件进行运算的情况,但不同的是左括号出栈时直接结束需当前的运算并且右括号不入栈.<br> 表达式读取完成后,运算符栈内可能仍存在运算符,因此需完成这些剩余运算符的运算.</li>
</ul>
</li>
</ul>
</li>
<li>特殊情况(负数)的处理<br>运算数为负数时,’-‘表示负号,为一元运算符,而非二元运减号(二元运算符).<br>处理方法:提前向运算数栈中压入一个0,将该负数转换为0与该负数绝对值的一次减法运算.<br>根据负号出现的位置分两种情况处理:<ul>
<li>负数出现在表达式开始处(第一个运算数为负数):开始运算前先将0压入运算数栈中.</li>
<li>负数出现在表达式中间或结尾处(括号中出现负数):读取到左括号时先将0压入运算数栈中,再将左括号压入运算符栈.</li>
</ul>
</li>
</ul>
<p>完成表达式的遍历后,栈中可能仍存在运算符.将这些剩余的运算符依次从栈顶弹出,并且添加到后缀表达式中(表示依次执行这些栈顶运算符的运算).最终得到后缀表达式将其输出.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现调度场算法,将中缀表达式转换为后缀表达式</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; opr;                      <span class="comment">//存储运算符</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; precedence;  <span class="comment">// 存储运算符的优先级</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; arity;       <span class="comment">// 存储运算符的元数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eraseSpace</span><span class="params">(string&amp; expr)</span>         <span class="comment">// 去除表达式中的空格</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = expr.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>); i != string::npos; i = expr.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>, i))</span><br><span class="line">        &#123;</span><br><span class="line">            expr.<span class="built_in">erase</span>(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initPrecedence</span><span class="params">(<span class="type">const</span> string &amp;tokens)</span>       <span class="comment">// 初始化优先级表</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> opr : tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (opr)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                precedence[opr] = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">                precedence[opr] = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>: precedence[opr] = <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;!&#x27;</span>: precedence[opr] = <span class="number">4</span>; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                precedence.<span class="built_in">insert</span>(&#123;opr, <span class="number">5</span>&#125;); <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\&#x27;&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                precedence[opr] = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initArity</span><span class="params">(<span class="type">const</span> string &amp;tokens)</span>            <span class="comment">// 初始化操作数表</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> opr : tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (opr)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">                    arity[opr] = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;!&#x27;</span>:</span><br><span class="line">                    arity[opr] = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\&#x27;&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                    arity[opr] = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">extractNumFromexpr</span><span class="params">(string expr, <span class="type">int</span>&amp; i)</span>  <span class="comment">//提取出表达式中的运算数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string opd;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(expr[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            opd += expr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(expr[i] == <span class="string">&#x27;.&#x27;</span>)  <span class="comment">// 考虑小数的情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            opd += expr[i++];</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isdigit</span>(expr[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                opd += expr[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> opd;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">infixToPostfix</span><span class="params">(string &amp;expr)</span>             <span class="comment">// 将中缀表达式转换为后缀表达式</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">eraseSpace</span>(expr);</span><br><span class="line">        <span class="function">string <span class="title">allOpr</span><span class="params">(<span class="string">&quot;+-*/%^!(\&#x27;)[\\]&#123;|&#125;&quot;</span>)</span></span>;        <span class="comment">// 表达式中所有可能出现的运算符</span></span><br><span class="line">        <span class="built_in">initPrecedence</span>(allOpr), <span class="built_in">initArity</span>(allOpr);  <span class="comment">// 建立运算符与其优先级和元数的映射</span></span><br><span class="line">        string postfixExpr;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *考虑特殊情况:运算数为负数,提前向运算数栈中压入一个0, 将运算数转换为0与该负数的绝对值进行一次减法运算的运算结果</span></span><br><span class="line"><span class="comment">        * 根据负数出现的位置分两种情况考虑：</span></span><br><span class="line"><span class="comment">        * 负数出现在表达式开头(第一个运算数为负数), 此时该负数不加括号;</span></span><br><span class="line"><span class="comment">        * 负数出现在表达式的中间和结尾(负数出现的位置不在表达式开头),此时该负数加括号;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 第一个运算数为负数的情况</span></span><br><span class="line">        <span class="keyword">if</span>(expr[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)    <span class="comment">// 该负数不加括号</span></span><br><span class="line">        &#123;</span><br><span class="line">            postfixExpr += <span class="string">&#x27;0&#x27;</span>;; <span class="comment">// 提前向后缀表达式中添加0, 将负数转换为0与该负数的绝对值的一次减法运算</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; expr.<span class="built_in">length</span>() &amp;&amp; expr[i] != <span class="string">&#x27;=&#x27;</span> ;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isalnum</span>(expr[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isalpha</span>(expr[i]))                            <span class="comment">//读取到变量</span></span><br><span class="line">                &#123;</span><br><span class="line">                    postfixExpr += expr[i++];                   <span class="comment">// !!!注意: 向后缀表达式中添加完该变量后需将i向后移,读取下一个字符</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>                                            <span class="comment">//读取到数字</span></span><br><span class="line">                &#123;</span><br><span class="line">                    postfixExpr += <span class="built_in">extractNumFromexpr</span>(expr, i); <span class="comment">//将该数字从表达式中进行提取,并且添加到后缀表达式中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                                <span class="comment">//读取到运算符</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> currOp = expr[i];                          <span class="comment">//记录当前的运算符</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * 运算条件为运算符栈非空(存在运算符)并且栈顶运算符的优先级不低于当前运算符的优先级</span></span><br><span class="line"><span class="comment">                * 若满足运算条件, 则代表进行一次运算, 弹出栈顶运算符</span></span><br><span class="line"><span class="comment">                * 再将新的栈顶运算符的优先级与当前运算符的优先级进行比较</span></span><br><span class="line"><span class="comment">                * 若满足运算条件,则重复上述过程, 直至栈顶运算符为空或者栈顶运算符的优先级低于当前运算符的优先级(不满足运算条件)</span></span><br><span class="line"><span class="comment">                * 此时已不满足运算条件,因此不进行运算:将当前运算符压入栈中</span></span><br><span class="line"><span class="comment">                * 特殊情况的合并: 当前运算符为右括号时,其优先级为最低, 继续完成括号内剩余运算符的运算,将这些运算符依次弹出(该情况合并到上述过程中进行运算条件的判断)</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">while</span>(!opr.<span class="built_in">empty</span>() &amp;&amp; precedence[opr.<span class="built_in">top</span>()] &gt;= precedence[expr[i]])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(arity[opr.<span class="built_in">top</span>()])   <span class="comment">//栈顶运算符为算术运算符</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 进行一次运算,将运算符添加到后缀表达式中</span></span><br><span class="line">                        postfixExpr += opr.<span class="built_in">top</span>();</span><br><span class="line">                        <span class="comment">// 完成此次运算 从栈中弹出运算符</span></span><br><span class="line">                        opr.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>                   <span class="comment">//当前的运算符为右括号,且栈顶运算符为左括号的情况</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        opr.<span class="built_in">pop</span>();        <span class="comment">//将左括号从运算符栈中弹出(左括号不添加到后缀表达式中)</span></span><br><span class="line">                        <span class="keyword">break</span>;            <span class="comment">//此时已经完成括号内的所有运算,跳出本次循环</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前运算符为左括号</span></span><br><span class="line">                <span class="keyword">if</span>(currOp == <span class="string">&#x27;(&#x27;</span> || currOp == <span class="string">&#x27;[&#x27;</span> || currOp == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                   <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    * 左括号入栈后表示将在括号内进行一段子运算,因此入栈后的左括号的优先级变为最低</span></span><br><span class="line"><span class="comment">                    * 使用ASCII码表中与左括号相邻的符号表示入栈后的左括号, 以实现入栈后左括号优先级发生变化</span></span><br><span class="line"><span class="comment">                    * 用单引号&#x27;\&#x27;&#x27;表示入栈后的左圆括号&#x27;(&#x27;, 原因:单引号的ASCII码值比左圆括号的ASCII值小1</span></span><br><span class="line"><span class="comment">                    * 用反斜杠&#x27;\\&#x27;表示入栈后的左方括号&#x27;[&#x27;, 原因:反斜杠的ASCII码值比左方括号的ASCII值大1</span></span><br><span class="line"><span class="comment">                    * 使用竖杠&#x27;|&#x27; 表示入栈后的左花括号&#x27;&#123;&#x27;, 原因:  竖杠的ASCII码值比左花括号的ASCII值大1</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    currOp == <span class="string">&#x27;(&#x27;</span> ? currOp-- : currOp++;</span><br><span class="line">                    <span class="keyword">if</span>(expr[i + <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>) <span class="comment">// 负数未出现在表达式开头的情况</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        postfixExpr += <span class="string">&#x27;0&#x27;</span>;;  <span class="comment">// 提取向后缀表达中添加&#x27;0&#x27;, 将运算数转换为0与该负数的绝对值进行一次减法运算</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(!(currOp == <span class="string">&#x27;)&#x27;</span> || currOp == <span class="string">&#x27;]&#x27;</span> || currOp == <span class="string">&#x27;&#125;&#x27;</span>))  <span class="comment">// 不满足运算条件, 当前运算符不是右括号时,将运算符入栈</span></span><br><span class="line">                &#123;</span><br><span class="line">                    opr.<span class="built_in">push</span>(currOp);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;                       <span class="comment">// 读取表达式的下一个字符</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读取完表达式后,还需完成运算符栈内剩余运算符的运算然后依次将运算符从栈中弹出</span></span><br><span class="line">        <span class="keyword">while</span>(!opr.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            postfixExpr += opr.<span class="built_in">top</span>();             <span class="comment">// 进行一次运算</span></span><br><span class="line">            opr.<span class="built_in">pop</span>();                            <span class="comment">// 此次运算已完成, 弹出运算符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> postfixExpr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string expr;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin, expr))</span><br><span class="line">    &#123;</span><br><span class="line">        string ret = <span class="built_in">Solution</span>().<span class="built_in">infixToPostfix</span>(expr);</span><br><span class="line">        cout &lt;&lt; ret &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
</search>
